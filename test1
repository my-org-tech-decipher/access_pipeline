// UTF-8 safe base64 helpers
function b64encUtf8(str){
  const utf8 = unescape(encodeURIComponent(str));
  let out=''; for (let i=0;i<utf8.length;i++) out+=String.fromCharCode(utf8.charCodeAt(i));
  return btoa(out);
}
function b64decUtf8(b64){
  const bin = atob(b64.replace(/\n/g,''));
  let out=''; for (let i=0;i<bin.length;i++) out += '%' + ('00'+bin.charCodeAt(i).toString(16)).slice(-2);
  return decodeURIComponent(out);
}

const owner  = pm.variables.get('owner');
const repo   = pm.variables.get('repo');
const path   = pm.variables.get('file_path');
const branch = pm.variables.get('branch');
const token  = pm.variables.get('github_token');
const addTxt = pm.variables.get('append_text') || "";

// 1) GET current file (content + sha)
pm.sendRequest({
  url: `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`,
  method: 'GET',
  header: {
    'Authorization': `Bearer ${token}`,
    'Accept': 'application/vnd.github+json'
  }
}, (err, res) => {
  if (err || !res) throw new Error('GET existing file failed: ' + (err?.message || 'no response'));
  if (res.code !== 200) throw new Error(`Expected 200, got ${res.code}. Check branch/path.`);

  const body = res.json();
  const sha = body.sha;
  const current = b64decUtf8(body.content);

  // 2) Append safely (insert a newline if needed)
  const needsNL = current.length && !current.endsWith('\n') && !addTxt.startsWith('\n');
  const combined = current + (needsNL ? '\n' : '') + addTxt;

  // 3) Build final payload
  const payload = {
    message: pm.variables.get('commit_message') || `append to ${path}`,
    content: b64encUtf8(combined),
    branch: branch,
    sha: sha
  };
  pm.variables.set('payload', JSON.stringify(payload));
});
